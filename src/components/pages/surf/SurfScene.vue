<template>
  <div class="point point-0">
    <div class="label label-0">1</div>
    <div class="text text-0">
      <el-row justify="center">
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                核电站的主要工作原理是：用铀制成的核燃料在反应堆内进行核裂变并释放出大量热能；高压下的循环冷却水把热能带出，在蒸汽产生器内生成蒸汽；高温高压的蒸汽推动汽轮机，进而推动发电机旋转。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                核电站一般分为两部分：利用原子核裂变生产蒸汽的核岛与利用蒸汽发电的常规岛。核岛是核电站的核心部分，一般包含核反应堆、压力容器、蒸汽发生器、主循环泵、稳压器及相应的管道、阀门等组成的回路系统。常规岛则主要包含汽轮发电机系统及其配套设施。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon class="icon" :icon="['fa-solid', 'fa-bolt']" />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                在2016年，全球核电站的总发电量达到了2606
                TWh，占全球发电量的约10.4%。目前我国核电站的普遍单堆功率大约在1000
                MW左右。
              </div>
            </el-col>
          </el-row>
        </el-col>
      </el-row>
    </div>
  </div>
  <div class="point point-1">
    <div class="label label-1">2</div>
    <div class="text text-1">
      <el-row justify="center">
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                火力发电是指靠燃烧化石燃料（煤、天然气或石油）来产生电能的发电方式。火力发电可以持续地大量发电，因此在许多国家，大部分电能均由火力发电厂提供。其通过各种旋转机械将燃烧产生的热能转换为机械能，然后驱动发电机。原动机通常是蒸汽机或燃气轮机，在一些较小的电站，也有可能会使用内燃机。他们都是通过利用高温、高压蒸汽或燃气通过涡轮变为低压空气或冷凝水这一过程中的压降来发电的。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon class="icon" :icon="['fa-solid', 'fa-bolt']" />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                在2016年，全球煤炭发电的总发电量达到了9594
                TWh，占全球发电量的约38.3%；全球天然气发电的总发电量达到了5794
                TWh，占全球发电量的约23.1%。一般来说火力发电的功率与其规模有关，现存最大的火力发电厂是内蒙古托克托电厂，其总装机容量为6720
                MW。
              </div>
            </el-col>
          </el-row>
        </el-col>
      </el-row>
    </div>
  </div>
  <div class="point point-2">
    <div class="label label-2">3</div>
    <div class="text text-2">
      <el-row justify="center">
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                太阳能发电是一种将阳光转换成电能的方式。其可直接使用太阳能光伏，或间接使用聚光太阳能热来发电。太阳能光伏是利用光伏半导体材料的光生伏打效应，将太阳能转化为直流电能；而聚光太阳能热发电系统会使用透镜或反射镜和跟踪系统将大面积的阳光聚焦成一个小束，并利用光电效应将光伏光转换成电流。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon class="icon" :icon="['fa-solid', 'fa-bolt']" />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                在2016年，全球太阳能发电的总发电量达到了338
                TWh，占全球发电量的约1.3%。
              </div>
            </el-col>
          </el-row>
        </el-col>
      </el-row>
    </div>
  </div>
  <div class="point point-3">
    <div class="label label-3">4</div>
    <div class="text text-3">
      <el-row justify="center">
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                风力发电机是一种将气流的动能转为机械能的装置，其通过风力带动风车叶片旋转，再通过增速机将旋转的速度提升，促使发电机发电。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon
                class="icon"
                :icon="['fa-solid', 'fa-circle-info']"
              />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                风电涡轮机由叶片、尾翼、转体、机头组成，其中叶片用来接受风力并通过机头转为电能；尾翼使叶片始终对着来风的方向从而获得最大的风能；转体能使机头灵活地转动以实现尾翼调整方向的功能；机头的转子是永磁体，通过切割磁力线产生电能。
              </div>
            </el-col>
          </el-row>
        </el-col>
        <el-col :span="24">
          <el-divider />
        </el-col>
        <el-col :span="24">
          <el-row justify="center">
            <el-col :span="1">
              <font-awesome-icon class="icon" :icon="['fa-solid', 'fa-bolt']" />
            </el-col>
            <el-col :span="22" :offset="1">
              <div class="content">
                在2016年，全球风能发电的总发电量达到了958
                TWh，占全球发电量的约3.8%。一般来说，一台风力发电机的功率在0-8
                MW之间不等，其具体的功率会受到其他因素的影响，例如风速、风的稳定性等。风速在10-16
                m/s时发电效率效率达到最高。
              </div>
            </el-col>
          </el-row>
        </el-col>
      </el-row>
    </div>
  </div>
  <div id="blocker">
    <div id="instructions">
      <SurfTutorial style="width: 50%" />
    </div>
  </div>
  <div id="index">
    <Renderer ref="myRenderer" shadow antialias resize="window">
      <Camera
        ref="myCamera"
        :position="{ x: 85, y: 5, z: -50 }"
        :lookAt="{ x: 0, y: 75, z: 0 }"
        :far="200000"
      />
      <Scene ref="myScene">
        <HemisphereLight
          ref="light"
          color="rgb(150, 197, 217)"
          groundColor="rgb(250, 250, 250)"
          :intensity="0.78"
        />
        <DirectionalLight
          ref="dir"
          color="rgb(100, 100, 100)"
          :intensity="1.5"
          :position="{ x: -100, y: 200, z: -1000 }"
          cast-shadow
        >
        </DirectionalLight>
        <!--        <PointLight-->
        <!--          ref="sun"-->
        <!--          color="rgb(7, 16, 33)"-->
        <!--          :intensity="0.13"-->
        <!--          :position="{ x: 120, y: 20 }"-->
        <!--          :decay="0"-->
        <!--          cast-shadow-->
        <!--        />-->
        <!--        <PointLight-->
        <!--          ref="light1"-->
        <!--          color="rgb(20, 20, 100)"-->
        <!--          :intensity="1.0"-->
        <!--          :position="{ x: -120, y: 20 }"-->
        <!--          :decay="0.5"-->
        <!--          cast-shadow-->
        <!--        />-->
        <!--        <SpotLight-->
        <!--          color="#555555"-->
        <!--          :distance="500"-->
        <!--          :angle="Math.PI / 2"-->
        <!--          :decay="0.5"-->
        <!--          :intensity="5"-->
        <!--          :position="{ y: 250 }"-->
        <!--          :target="{ y: 500 }"-->
        <!--        />-->

        <GltfModel
          ref="mainscene"
          src="/static/mainScene.glb"
          dracoPath="/draco/"
          :scale="{ x: 100, y: 100, z: 100 }"
          :position="{ x: 0, y: 0, z: 0 }"
          :rotation="{ y: -0.96 }"
        />
        <!-- cloud -->
        <!--        <Plane-->
        <!--          v-for="i in 15"-->
        <!--          :ref="`mesh${i}`"-->
        <!--          :width="500"-->
        <!--          :height="500"-->
        <!--          :position="{-->
        <!--            x: Math.random() * 800 - 400,-->
        <!--            y: 400,-->
        <!--            z: Math.random() * 800 - 400,-->
        <!--          }"-->
        <!--          :rotation="{ x: Math.PI / 2, y: 0, z: Math.random() * 360 }"-->
        <!--        >-->
        <!--          <StandardMaterial-->
        <!--            :props="{ transparent: true, opacity: 0.6, depthWrite: false }"-->
        <!--          >-->
        <!--            <Texture src="/assets/textures/smoke.png" />-->
        <!--          </StandardMaterial>-->
        <!--        </Plane>-->

        <!--        <Plane-->
        <!--          :rotation="{ x: -Math.PI / 2 }"-->
        <!--          :width="800"-->
        <!--          :height="800"-->
        <!--          :widthSegments="64"-->
        <!--          :heightSegments="64"-->
        <!--          :position="{ x: -32.61, y: -13.35, z: 8.7 }"-->
        <!--          receive-shadow-->
        <!--        >-->
        <!--          <StandardMaterial :props="{ displacementScale: 20 }">-->
        <!--            <Texture src="/assets/textures/green3c5942.png" />-->
        <!--            <Texture-->
        <!--              src="/assets/textures/background.png"-->
        <!--              name="displacementMap"-->
        <!--            />-->
        <!--          </StandardMaterial>-->
        <!--        </Plane>-->
      </Scene>
    </Renderer>
  </div>
</template>

<script setup>
import SurfTutorial from "@/components/pages/surf/SurfTutorial.vue";
import * as THREE from "three";
import { MathUtils, Object3D, Vector3 } from "three";
import { ref, computed, watch, onMounted, onUnmounted } from "vue";
import { NButton, NProgress } from "naive-ui";
import { Water } from "three/examples/jsm/objects/Water.js";

import { Sky } from "three/examples/jsm/objects/Sky";

const { randFloat: rnd, randFloatSpread: rndFS } = MathUtils;
import { PointerLockControls } from "three/addons/controls/PointerLockControls";
import { OrbitControls } from "three/addons/controls/OrbitControls";
import { GUI } from "three/addons/libs/lil-gui.module.min";
import { FontAwesomeIcon } from "@fortawesome/vue-fontawesome";

//Loading Manager
const percent = ref(0);
THREE.DefaultLoadingManager.onProgress = function (
  url,
  itemsLoaded,
  itemsTotal
) {
  percent.value = (itemsLoaded / itemsTotal) * 100;
};

//textures

// threejs/troisjs
let renderer, scene, camera;

// wander
let controls;

let objects = [];

let raycaster;

let moveForward = false;
let moveBackward = false;
let moveLeft = false;
let moveRight = false;
let canJump = false;

let prevTime = performance.now();
const jumpHeight = 200;
const eyeHeight = 10;
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const vertex = new THREE.Vector3();
const color = new THREE.Color();

const myRenderer = ref(null);
const myScene = ref(null);
const myCamera = ref(null);
const mainscene = ref(null);

let water;

let points;

// camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
// camera.position.y = 10;
//
// scene = new THREE.Scene();
// scene.background = new THREE.Color( 0xffffff );
// scene.fog = new THREE.Fog( 0xffffff, 0, 750 );
//
// const light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
// light.position.set( 0.5, 1, 0.75 );
// scene.add( light );

const rayCaster_labelVisible = new THREE.Raycaster();

const onKeyDown = function (event) {
  switch (event.code) {
    case "ArrowUp":
    case "KeyW":
      moveForward = true;
      break;

    case "ArrowLeft":
    case "KeyA":
      moveLeft = true;
      break;

    case "ArrowDown":
    case "KeyS":
      moveBackward = true;
      break;

    case "ArrowRight":
    case "KeyD":
      moveRight = true;
      break;

    case "Space":
      if (canJump === true) velocity.y += jumpHeight;
      canJump = false;
      break;
  }
};

const onKeyUp = function (event) {
  switch (event.code) {
    case "ArrowUp":
    case "KeyW":
      moveForward = false;
      break;

    case "ArrowLeft":
    case "KeyA":
      moveLeft = false;
      break;

    case "ArrowDown":
    case "KeyS":
      moveBackward = false;
      break;

    case "ArrowRight":
    case "KeyD":
      moveRight = false;
      break;
  }
};

const checkLabelVisible = function () {
  if (true) {
    // 遍历每个点
    for (const point of points) {
      // 获取2D屏幕位置
      const screenPosition = point.position.clone();
      screenPosition.project(camera);
      rayCaster_labelVisible.setFromCamera(screenPosition, camera);
      const intersects = rayCaster_labelVisible.intersectObjects(
        scene.children,
        true
      );

      const controlsPos = controls.getObject().position;
      const dis = controlsPos.distanceTo(point.position);
      // 计算距离 显示文字
      if (dis < 30) {
        point.text.classList.add("activate");
      } else {
        point.text.classList.remove("activate");
      }

      if (intersects.length === 0) {
        // 未找到相交点，显示
        point.element.classList.add("visible");
      } else {
        // 找到相交点
        // 获取相交点的距离和点的距离
        const intersectionDistance = intersects[0].distance;
        const pointDistance = point.position.distanceTo(camera.position);
        // 相交点距离比点距离近，隐藏；相交点距离比点距离远，显示
        intersectionDistance < pointDistance
          ? point.element.classList.remove("visible")
          : point.element.classList.add("visible");
      }
      let element = document.getElementById("index");
      const translateX = screenPosition.x * element.clientWidth * 0.5;
      const translateY = -screenPosition.y * element.clientHeight * 0.5;
      point.element.style.transform = `translateX(${translateX}px) translateY(${translateY}px)`;
    }
  }
};

const collideCheck = (angle) => {
  console.log(controls.getObject().position);

  let rotationMatrix = new THREE.Matrix4();
  rotationMatrix.makeRotationY((angle * Math.PI) / 180);
  const cameraDirection = controls
    .getDirection(new THREE.Vector3(0, 0, 0))
    .clone();
  cameraDirection.applyMatrix4(rotationMatrix);
  const raycaster = new THREE.Raycaster(
    controls.getObject().position.clone(),
    cameraDirection,
    0,
    5
  ); //射线长度为5 一条较短的射线
  raycaster.ray.origin.y -= eyeHeight;
  const intersections = raycaster.intersectObjects(objects, false);
  return intersections.length;
};

const getMesh = (parent) => {
  parent.forEach((item) => {
    if (item.type === "Mesh") objects.push(item);
    else if (item.type === "Group") getMesh(item.children);
  });
};

onMounted(() => {
  points = [
    {
      position: new THREE.Vector3(-320, 44, -22),
      element: document.querySelector(".point-0"),
      text: document.querySelector(".text-0"),
    },
    {
      position: new THREE.Vector3(-193, 45, -96),
      element: document.querySelector(".point-1"),
      text: document.querySelector(".text-1"),
    },
    {
      position: new THREE.Vector3(97, 221, 101),
      element: document.querySelector(".point-2"),
      text: document.querySelector(".text-2"),
    },
    {
      position: new THREE.Vector3(-320, 31, 291),
      element: document.querySelector(".point-3"),
      text: document.querySelector(".text-3"),
    },
  ];

  //scene core
  renderer = myRenderer.value;
  scene = myScene.value.scene;
  camera = myCamera.value.camera;
  // scene.fog = new THREE.Fog(this.skycolor, 1, 800);

  // Set window size
  let element = document.getElementById("index");
  renderer.three.setSize(element.clientWidth, element.clientHeight);

  // const orbitCtrl = new OrbitControls(camera, renderer.domElement);
  // orbitCtrl.enableRotate = false;
  // orbitCtrl.enableZoom = false;
  // scene.add(orbitCtrl);

  // wander
  controls = new PointerLockControls(camera, document.body);
  controls.getObject().position.set(-450, 17, -118);
  controls.getObject().lookAt(0, 0, 0);

  const blocker = document.getElementById("blocker");
  const instructions = document.getElementById("instructions");

  instructions.addEventListener("click", function () {
    controls.lock();
  });

  controls.addEventListener("lock", function () {
    instructions.style.display = "none";
    blocker.style.display = "none";
  });

  controls.addEventListener("unlock", function () {
    blocker.style.display = "block";
    instructions.style.display = "";
  });

  scene.add(controls.getObject());

  document.addEventListener("keydown", onKeyDown);
  document.addEventListener("keyup", onKeyUp);

  raycaster = new THREE.Raycaster(
    new THREE.Vector3(),
    new THREE.Vector3(0, -1, 0),
    0,
    10
  );

  //skybox
  // let texture = [];
  // let material = [];
  // const imageArray = Array(6).fill("/assets/skybox/sky.png");
  // imageArray.forEach((el) => texture.push(new THREE.TextureLoader().load(el)));
  // texture.forEach((el) =>
  //   material.push(new THREE.MeshStandardMaterial({ map: el }))
  // );
  // for (let i = 0; i < 6; i++) material[i].side = THREE.BackSide;
  // let skyboxGeo = new THREE.BoxGeometry(5000, 5000, 5000);
  // let skybox = new THREE.Mesh(skyboxGeo, material);
  // scene.add(skybox);

  // Add Sky
  const sky = new Sky();
  sky.scale.setScalar(450000);
  scene.add(sky);

  const sun = new THREE.Vector3();

  /// GUI

  var effectController = {
    turbidity: 10,
    rayleigh: 3,
    mieCoefficient: 0.005,
    mieDirectionalG: 0.7,
    inclination: 2, // elevation / inclination
    azimuth: 180, // Facing front,
    exposure: renderer.toneMappingExposure,
  };

  function guiChanged() {
    var uniforms = sky.material.uniforms;
    uniforms["turbidity"].value = effectController.turbidity;
    uniforms["rayleigh"].value = effectController.rayleigh;
    uniforms["mieCoefficient"].value = effectController.mieCoefficient;
    uniforms["mieDirectionalG"].value = effectController.mieDirectionalG;
    var theta = Math.PI * (effectController.inclination - 0.5);
    var phi = 2 * Math.PI * (effectController.azimuth - 0.5);
    sun.x = Math.cos(phi);
    sun.y = Math.sin(phi) * Math.sin(theta);
    sun.z = Math.sin(phi) * Math.cos(theta);

    uniforms["sunPosition"].value.copy(sun);
    renderer.toneMappingExposure = effectController.exposure;
    // renderer.render(scene, camera);
  }
  // var gui = new GUI();

  // gui.add(effectController, "turbidity", 0.0, 20.0, 0.1).onChange(guiChanged);
  // gui.add(effectController, "rayleigh", 0.0, 4, 0.001).onChange(guiChanged);
  // gui
  //   .add(effectController, "mieCoefficient", 0.0, 0.1, 0.001)
  //   .onChange(guiChanged);
  // gui
  //   .add(effectController, "mieDirectionalG", 0.0, 1, 0.001)
  //   .onChange(guiChanged);
  // gui.add(effectController, "inclination", 0, 1, 0.0001).onChange(guiChanged);
  // gui.add(effectController, "azimuth", 0, 1, 0.0001).onChange(guiChanged);
  // gui.add(effectController, "exposure", 0, 1, 0.0001).onChange(guiChanged);
  guiChanged();
  //water

  const waterGeometry = new THREE.CircleGeometry(5000, 100);
  water = new Water(waterGeometry, {
    textureWidth: 1000,
    textureHeight: 1000,
    waterNormals: new THREE.TextureLoader().load(
      "/assets/textures/water.jpg",
      function (texture) {
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
      }
    ),
    waterColor: "rgb(150, 197, 217)",
    sunColor: "rgb(250, 250, 250)",
    distortionScale: 5,
    fog: scene.fog !== undefined,
  });
  // water = water;
  water.rotation.x = -Math.PI / 2;
  scene.add(water);

  //ANIMATION LOOP
  renderer.onBeforeRender(() => {
    const time = performance.now();
    water.material.uniforms["time"].value += 0.7 / 60.0;

    objects = [];
    getMesh(scene.children);

    if (controls.isLocked === true) {
      raycaster.ray.origin.copy(controls.getObject().position);
      raycaster.ray.origin.y -= 10;

      const intersections = raycaster.intersectObjects(objects, false);

      const onObject = intersections.length > 0;

      const delta = (time - prevTime) / 1000;

      // 四个方位是否产生碰撞
      let leftCollide = false;
      let rightCollide = false;
      let forwardCollide = false;
      let backCollide = false;

      // 碰撞检测 collide check
      if (moveForward) forwardCollide = collideCheck(0);
      if (moveBackward) backCollide = collideCheck(180);
      if (moveLeft) leftCollide = collideCheck(90);
      if (moveRight) rightCollide = collideCheck(270);

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize(); // this ensures consistent movements in all directions

      if (moveForward || moveBackward)
        velocity.z -= direction.z * 400.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

      if (onObject === true) {
        velocity.y = Math.max(0, velocity.y);
        canJump = true;
      }

      // 计算移动距离
      let rightDistance = -velocity.x * delta;
      let forwardDistance = -velocity.z * delta;

      // 右侧有障碍物时向右移动 置零
      if ((moveRight && rightCollide) || (moveLeft && leftCollide)) {
        rightDistance = 0;
      }

      // 前方有障碍物时向前移动 置零
      if ((moveForward && forwardCollide) || (moveBackward && backCollide)) {
        forwardDistance = 0;
      }

      // 设置最终移动值
      if (moveLeft || moveRight) controls.moveRight(rightDistance);

      if (moveForward || moveBackward) controls.moveForward(forwardDistance);

      controls.getObject().position.y += velocity.y * delta; // new behavior

      if (controls.getObject().position.y < 10) {
        velocity.y = 0;
        controls.getObject().position.y = 10;

        canJump = true;
      }
    }

    prevTime = time;

    // visible
    checkLabelVisible();
  });
});

onUnmounted(() => {
  // disposeScene();
});
</script>

<style scoped>
.switch-enter-active,
.switch-leave-active {
  --transition-time: 1s;
}

* {
  font-family: "Montserrat", sans-serif;
  box-sizing: border-box;
}

body {
  margin: 0;
}

a {
  text-decoration: inherit;
  color: inherit;
}

canvas {
  display: block;
}

.absolute {
  position: absolute;
}

.center {
  transform: translate(-50%, 0);
  left: 50%;
}

.menu {
  text-align: center;
}

.menu h1,
p,
h2 {
  color: white;
}

.menu h1 {
  margin: 0 auto 5px;
}

.menu p {
  margin: 2vh auto 0;
}

.btn::before {
  content: "";
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  height: var(--border-height);
  background-color: white;
  transition: transform 300ms ease-in-out;
  transform: scaleX(0);
}

.btn:hover::before,
.btn:focus::before {
  transform: scaleX(1);
}

#blocker {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
}

#instructions {
  width: 100%;
  height: 100%;

  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;

  text-align: center;
  font-size: 14px;
  cursor: pointer;
}

.point {
  left: 50%;
  position: fixed;
  top: 50%;
  z-index: 10;
}

.point .label {
  background: rgba(0, 0, 0, 0.467);
  border: 1px solid hsla(0, 0%, 100%, 0.467);
  border-radius: 50%;
  cursor: help;
  height: 32px;
  left: -16px;
  line-height: 32px;
  text-align: center;
  top: -16px;
  -webkit-transform: scale(0);
  transform: scale(0);
  transition: -webkit-transform 0.3s;
  transition: transform 0.3s;
  width: 32px;
}

.point .label,
.point .text {
  color: #fff;
  font-family: Helvetica, Arial, sans-serif;
  font-size: 14px;
  font-weight: 100;
  position: absolute;
}

.point .text {
  background: rgba(0, 0, 0, 0.6);
  border: 1px solid hsla(0, 0%, 100%, 0.467);
  border-radius: 4px;
  left: -120px;
  line-height: 1.3em;
  opacity: 0;
  padding: 20px;
  pointer-events: none;
  text-align: justify;
  text-align-last: left;
  top: 30px;
  transition: opacity 0.3s;
  width: 400px;
}

.point .text.activate {
  opacity: 1;
}

.point.visible .label {
  -webkit-transform: scale(1);
  transform: scale(1);
}
.icon {
  color: white;
}
.title {
  font-weight: bold;
  color: white;
  /*text-align: center;*/
}
.content {
  color: white;
}
.el-divider--horizontal {
  margin: 8px 0;
  background: 0 0;
  border-top: 1px dashed #e8eaec;
}
</style>
